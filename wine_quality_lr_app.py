# -*- coding: utf-8 -*-
"""wine_quality_lr_app.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1q7ydZqBnwO9eeDoFFjOOrlk2sWuc7Fs1
"""

from flask import Flask, render_template, request, redirect, url_for, session, flash
import pickle
import numpy as np
import pandas as pd

# ***Code to read in model, accept user input written in index.html, and predict using model***

app = Flask(__name__)
app.secret_key = "so_not_helpful"

# Model's features that will appear on the form
FORM_FIELDS = ["fixed_acidity", "volatile_acidity",
               "citric_acid", "residual_sugar", "chlorides",
               "free_sulfur_dioxide", "total_sulfur_dioxide",
               "density", "pH", "sulphates", "alcohol"]

def make_prediction(form_data):
    pred = None

    def require_float(name):
        # Fail fast so we don't silently use zeros
        val = form_data.get(name, None)
        if val is None or str(val).strip() == "":
            raise ValueError(f"Missing value for '{name}'")
        try:
            return float(val)
        except ValueError:
            raise ValueError(f"Invalid number for '{name}': {val}")


    # Ensures entry is floating point number if they enter integer
    def to_float(x, default=0.0):
        try:
            return float(x)
        except (TypeError, ValueError):
            return default

    TRAIN_COLS = ["fixed_acidity","volatile_acidity","citric_acid","residual_sugar",
                  "chlorides","free_sulfur_dioxide","total_sulfur_dioxide","density",
                  "pH","sulphates","alcohol"]

    # Build a row in the exact training order
    row = {c: float(form_data[c]) for c in TRAIN_COLS}
    X_df = pd.DataFrame([row], columns=TRAIN_COLS)

    # Get class probabilities
    probs = lr.predict_proba(X_df)[0]   # shape (n_classes,)
    classes = lr.classes_                   # e.g. [3, 4, 5, 6, 7, 8, 9]

    # Pair up class â†’ prob
    class_probs = list(zip(classes, probs))

    # Sort by probability
    top3 = sorted(class_probs, key=lambda t: t[1], reverse=True)[:3]

    # Headline prediction (top class)
    best_class, best_prob = top3[0]
    prediction_text = f"Predicted wine quality: {best_class} ({best_prob:.0%})"

    # Exclude the best from "other likely"
    others = top3[1:]   # skip the first one
    other_text = " / ".join([f"{cls}: {p:.0%}" for cls, p in others])

    # Use \n for carriage return (newline)
    return f"{prediction_text}\nOther likely: {other_text}"

# Load model, scaler, and encoders
try:
  lr = pickle.load(open('lr.pkl', 'rb'))
except FileNotFoundError as e:
    raise Exception(f"Pickle file not found: {str(e)}")
except Exception as e:
    raise Exception(f"Error loading pickle file: {str(e)}")

@app.route('/', methods=["GET", "POST"])
def index():
    if request.method == "POST":
        # which button did they click?
        if "predict" in request.form:

            # keep submitted values in session
            session["form_values"] = {i: request.form.get(i, "") for i in FORM_FIELDS}

            # run prediction
            session["prediction"] = make_prediction(session["form_values"])

            # redirect to avoid resubmission on refresh
            return redirect(url_for("index"))

        if "clear" in request.form:
            session.pop("form_values", None)
            session.pop("prediction", None)
            return redirect(url_for("index"))

    # GET: render with whatever is in session (or defaults)
    values = session.get("form_values", {i: "" for i in FORM_FIELDS})
    prediction = session.get("prediction")
    return render_template("index.html", values=values, prediction=prediction)

if __name__ == '__main__':
    app.run(debug=True)